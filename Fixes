from pathlib import Path
import importlib.util
import sys
import time
import ast
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from PyQt6.QtWidgets import QMainWindow, QWidget
from PyQt6.QtCore import QObject

class HotReloader(QObject):
    def __init__(self, file_path):
        super().__init__()
        self.file_path = Path(file_path)
        self.project_root = self.find_project_root()
        self.main_window = None
        self.module = None
        self.observer = None
        
        # Add project root to Python path
        if str(self.project_root) not in sys.path:
            sys.path.insert(0, str(self.project_root))
        
        # Install dependencies from requirements.txt
        self.install_requirements()
        
        self.start_file_observer()
        self.load_window()

    def find_project_root(self):
        """Find the project root by looking for requirements.txt"""
        current = self.file_path.parent
        while current != current.parent:
            if (current / 'requirements.txt').exists():
                return current
            current = current.parent
        return self.file_path.parent  # Fallback to file's directory

    def install_requirements(self):
        """Install dependencies from requirements.txt"""
        requirements_file = self.project_root / 'requirements.txt'
        if not requirements_file.exists():
            print("No requirements.txt found in project root")
            return

        try:
            import subprocess
            print("Installing dependencies from requirements.txt...")
            subprocess.check_call([
                sys.executable, 
                '-m', 
                'pip', 
                'install', 
                '-r', 
                str(requirements_file)
            ])
            print("Dependencies installed successfully")
        except subprocess.CalledProcessError as e:
            print(f"Error installing dependencies: {str(e)}")
            raise

    def resolve_local_import(self, import_name, current_dir):
        """Resolve a local import to its absolute path"""
        # Check in the same directory
        local_path = current_dir / f"{import_name}.py"
        if local_path.exists():
            return local_path

        # Check in project root and its subdirectories
        for path in self.project_root.rglob(f"{import_name}.py"):
            return path

        return None

    def load_module(self, module_path, package=None):
        """Load a Python module from file path"""
        module_name = module_path.stem
        if package:
            module_name = f"{package}.{module_name}"

        spec = importlib.util.spec_from_file_location(module_name, module_path)
        if spec is None:
            raise ImportError(f"Could not load module: {module_path}")

        module = importlib.util.module_from_spec(spec)
        sys.modules[module_name] = module
        try:
            spec.loader.exec_module(module)
            return module
        except Exception as e:
            if module_name in sys.modules:
                del sys.modules[module_name]
            raise ImportError(f"Error loading module {module_path}: {str(e)}")

    def load_window(self):
        try:
            # Clear any existing instances
            if self.main_window:
                self.main_window.close()

            # Clear all project-related modules
            project_path_str = str(self.project_root)
            modules_to_reload = [
                name for name, module in sys.modules.items()
                if hasattr(module, '__file__') 
                and str(module.__file__).startswith(project_path_str)
            ]
            for module_name in modules_to_reload:
                del sys.modules[module_name]

            # Load the main module and its local imports
            self.module = self.load_module(self.file_path)

            # Find the main window class
            main_window_class = None
            for attr_name in dir(self.module):
                attr = getattr(self.module, attr_name)
                if isinstance(attr, type) and (issubclass(attr, QMainWindow) or issubclass(attr, QWidget)):
                    if attr != QMainWindow and attr != QWidget:
                        main_window_class = attr
                        break

            if not main_window_class:
                raise Exception("No QMainWindow or QWidget subclass found in the module")

            # Create and show the window
            self.main_window = main_window_class()
            self.main_window.show()

        except Exception as e:
            print(f"Error loading window: {str(e)}")
            raise

    def start_file_observer(self):
        class FileChangeHandler(FileSystemEventHandler):
            def __init__(self, callback):
                self.callback = callback
                self.last_modified = 0
                self.cooldown = 0.5

            def on_modified(self, event):
                if event.src_path.endswith('.py'):
                    current_time = time.time()
                    if current_time - self.last_modified > self.cooldown:
                        self.last_modified = current_time
                        try:
                            self.callback.load_window()
                        except Exception as e:
                            print(f"Error reloading window: {str(e)}")

        self.observer = Observer()
        event_handler = FileChangeHandler(self)
        self.observer.schedule(event_handler, str(self.project_root), recursive=True)
        self.observer.start()

def main(file_path):
    """Initialize and run the hot reloader"""
    try:
        reloader = HotReloader(file_path)
        return reloader
    except Exception as e:
        print(f"Error initializing hot reloader: {str(e)}")
        raise

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python hot-reloader.py <path_to_qt_file>")
        sys.exit(1)
    
    main(sys.argv[1])
